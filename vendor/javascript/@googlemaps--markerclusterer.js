import t from"fast-deep-equal";import e from"supercluster";function __rest(t,e){var r={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(r[s]=t[s]);if(t!=null&&typeof Object.getOwnPropertySymbols==="function"){var o=0;for(s=Object.getOwnPropertySymbols(t);o<s.length;o++)e.indexOf(s[o])<0&&Object.prototype.propertyIsEnumerable.call(t,s[o])&&(r[s[o]]=t[s[o]])}return r}class MarkerUtils{static isAdvancedMarkerAvailable(t){return google.maps.marker&&t.getMapCapabilities().isAdvancedMarkersAvailable===true}static isAdvancedMarker(t){return google.maps.marker&&t instanceof google.maps.marker.AdvancedMarkerElement}static setMap(t,e){this.isAdvancedMarker(t)?t.map=e:t.setMap(e)}static getPosition(t){if(this.isAdvancedMarker(t)){if(t.position){if(t.position instanceof google.maps.LatLng)return t.position;if(t.position.lat&&t.position.lng)return new google.maps.LatLng(t.position.lat,t.position.lng)}return new google.maps.LatLng(null)}return t.getPosition()}static getVisible(t){return!!this.isAdvancedMarker(t)||t.getVisible()}}class Cluster{constructor({markers:t,position:e}){this.markers=t;e&&(e instanceof google.maps.LatLng?this._position=e:this._position=new google.maps.LatLng(e))}get bounds(){if(this.markers.length===0&&!this._position)return;const t=new google.maps.LatLngBounds(this._position,this._position);for(const e of this.markers)t.extend(MarkerUtils.getPosition(e));return t}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter((t=>MarkerUtils.getVisible(t))).length}push(t){this.markers.push(t)}delete(){if(this.marker){MarkerUtils.setMap(this.marker,null);this.marker=void 0}this.markers.length=0}}
/**
 * Returns the markers visible in a padded map viewport
 *
 * @param map
 * @param mapCanvasProjection
 * @param markers The list of marker to filter
 * @param viewportPaddingPixels The padding in pixel
 * @returns The list of markers in the padded viewport
 */const filterMarkersToPaddedViewport=(t,e,r,s)=>{const o=extendBoundsToPaddedViewport(t.getBounds(),e,s);return r.filter((t=>o.contains(MarkerUtils.getPosition(t))))};const extendBoundsToPaddedViewport=(t,e,r)=>{const{northEast:s,southWest:o}=latLngBoundsToPixelBounds(t,e);const a=extendPixelBounds({northEast:s,southWest:o},r);return pixelBoundsToLatLngBounds(a,e)};const getPaddedViewport=(t,e,r)=>{const s=extendBoundsToPaddedViewport(t,e,r);const o=s.getNorthEast();const a=s.getSouthWest();return[a.lng(),a.lat(),o.lng(),o.lat()]};const distanceBetweenPoints=(t,e)=>{const r=6371;const s=(e.lat-t.lat)*Math.PI/180;const o=(e.lng-t.lng)*Math.PI/180;const a=Math.sin(s/2);const i=Math.sin(o/2);const n=a*a+Math.cos(t.lat*Math.PI/180)*Math.cos(e.lat*Math.PI/180)*i*i;const l=2*Math.atan2(Math.sqrt(n),Math.sqrt(1-n));return r*l};const latLngBoundsToPixelBounds=(t,e)=>({northEast:e.fromLatLngToDivPixel(t.getNorthEast()),southWest:e.fromLatLngToDivPixel(t.getSouthWest())});const extendPixelBounds=({northEast:t,southWest:e},r)=>{t.x+=r;t.y-=r;e.x-=r;e.y+=r;return{northEast:t,southWest:e}};const pixelBoundsToLatLngBounds=({northEast:t,southWest:e},r)=>{const s=r.fromDivPixelToLatLng(e);const o=r.fromDivPixelToLatLng(t);return new google.maps.LatLngBounds(s,o)};class AbstractAlgorithm{constructor({maxZoom:t=16}){this.maxZoom=t}noop({markers:t}){return noop(t)}}class AbstractViewportAlgorithm extends AbstractAlgorithm{constructor(t){var{viewportPadding:e=60}=t,r=__rest(t,["viewportPadding"]);super(r);this.viewportPadding=60;this.viewportPadding=e}calculate({markers:t,map:e,mapCanvasProjection:r}){return e.getZoom()>=this.maxZoom?{clusters:this.noop({markers:t}),changed:false}:{clusters:this.cluster({markers:filterMarkersToPaddedViewport(e,r,t,this.viewportPadding),map:e,mapCanvasProjection:r})}}}const noop=t=>{const e=t.map((t=>new Cluster({position:MarkerUtils.getPosition(t),markers:[t]})));return e};class GridAlgorithm extends AbstractViewportAlgorithm{constructor(t){var{maxDistance:e=4e4,gridSize:r=40}=t,s=__rest(t,["maxDistance","gridSize"]);super(s);this.clusters=[];this.state={zoom:-1};this.maxDistance=e;this.gridSize=r}calculate({markers:e,map:r,mapCanvasProjection:s}){const o={zoom:r.getZoom()};let a=false;this.state.zoom>=this.maxZoom&&o.zoom>=this.maxZoom||(a=!t(this.state,o));this.state=o;return r.getZoom()>=this.maxZoom?{clusters:this.noop({markers:e}),changed:a}:{clusters:this.cluster({markers:filterMarkersToPaddedViewport(r,s,e,this.viewportPadding),map:r,mapCanvasProjection:s})}}cluster({markers:t,map:e,mapCanvasProjection:r}){this.clusters=[];t.forEach((t=>{this.addToClosestCluster(t,e,r)}));return this.clusters}addToClosestCluster(t,e,r){let s=this.maxDistance;let o=null;for(let e=0;e<this.clusters.length;e++){const r=this.clusters[e];const a=distanceBetweenPoints(r.bounds.getCenter().toJSON(),MarkerUtils.getPosition(t).toJSON());if(a<s){s=a;o=r}}if(o&&extendBoundsToPaddedViewport(o.bounds,r,this.gridSize).contains(MarkerUtils.getPosition(t)))o.push(t);else{const e=new Cluster({markers:[t]});this.clusters.push(e)}}}class NoopAlgorithm extends AbstractAlgorithm{constructor(t){var e=__rest(t,[]);super(e)}calculate({markers:t,map:e,mapCanvasProjection:r}){return{clusters:this.cluster({markers:t,map:e,mapCanvasProjection:r}),changed:false}}cluster(t){return this.noop(t)}}class SuperClusterAlgorithm extends AbstractAlgorithm{constructor(t){var{maxZoom:r,radius:s=60}=t,o=__rest(t,["maxZoom","radius"]);super({maxZoom:r});this.state={zoom:-1};this.superCluster=new e(Object.assign({maxZoom:this.maxZoom,radius:s},o))}calculate(e){let r=false;const s={zoom:e.map.getZoom()};if(!t(e.markers,this.markers)){r=true;this.markers=[...e.markers];const t=this.markers.map((t=>{const e=MarkerUtils.getPosition(t);const r=[e.lng(),e.lat()];return{type:"Feature",geometry:{type:"Point",coordinates:r},properties:{marker:t}}}));this.superCluster.load(t)}r||(this.state.zoom<=this.maxZoom||s.zoom<=this.maxZoom)&&(r=!t(this.state,s));this.state=s;r&&(this.clusters=this.cluster(e));return{clusters:this.clusters,changed:r}}cluster({map:t}){return this.superCluster.getClusters([-180,-90,180,90],Math.round(t.getZoom())).map((t=>this.transformCluster(t)))}transformCluster({geometry:{coordinates:[t,e]},properties:r}){if(r.cluster)return new Cluster({markers:this.superCluster.getLeaves(r.cluster_id,Infinity).map((t=>t.properties.marker)),position:{lat:e,lng:t}});const s=r.marker;return new Cluster({markers:[s],position:MarkerUtils.getPosition(s)})}}class SuperClusterViewportAlgorithm extends AbstractViewportAlgorithm{constructor(t){var{maxZoom:r,radius:s=60,viewportPadding:o=60}=t,a=__rest(t,["maxZoom","radius","viewportPadding"]);super({maxZoom:r,viewportPadding:o});this.superCluster=new e(Object.assign({maxZoom:this.maxZoom,radius:s},a));this.state={zoom:-1,view:[0,0,0,0]}}calculate(e){const r={zoom:Math.round(e.map.getZoom()),view:getPaddedViewport(e.map.getBounds(),e.mapCanvasProjection,this.viewportPadding)};let s=!t(this.state,r);if(!t(e.markers,this.markers)){s=true;this.markers=[...e.markers];const t=this.markers.map((t=>{const e=MarkerUtils.getPosition(t);const r=[e.lng(),e.lat()];return{type:"Feature",geometry:{type:"Point",coordinates:r},properties:{marker:t}}}));this.superCluster.load(t)}if(s){this.clusters=this.cluster(e);this.state=r}return{clusters:this.clusters,changed:s}}cluster({map:t,mapCanvasProjection:e}){const r={zoom:Math.round(t.getZoom()),view:getPaddedViewport(t.getBounds(),e,this.viewportPadding)};return this.superCluster.getClusters(r.view,r.zoom).map((t=>this.transformCluster(t)))}transformCluster({geometry:{coordinates:[t,e]},properties:r}){if(r.cluster)return new Cluster({markers:this.superCluster.getLeaves(r.cluster_id,Infinity).map((t=>t.properties.marker)),position:{lat:e,lng:t}});const s=r.marker;return new Cluster({markers:[s],position:MarkerUtils.getPosition(s)})}}class ClusterStats{constructor(t,e){this.markers={sum:t.length};const r=e.map((t=>t.count));const s=r.reduce(((t,e)=>t+e),0);this.clusters={count:e.length,markers:{mean:s/e.length,sum:s,min:Math.min(...r),max:Math.max(...r)}}}}class DefaultRenderer{render({count:t,position:e},r,s){const o=t>Math.max(10,r.clusters.markers.mean)?"#ff0000":"#0000ff";const a=`<svg fill="${o}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">\n<circle cx="120" cy="120" opacity=".6" r="70" />\n<circle cx="120" cy="120" opacity=".3" r="90" />\n<circle cx="120" cy="120" opacity=".2" r="110" />\n<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>\n</svg>`;const i=`Cluster of ${t} markers`,n=Number(google.maps.Marker.MAX_ZINDEX)+t;if(MarkerUtils.isAdvancedMarkerAvailable(s)){const t=new DOMParser;const r=t.parseFromString(a,"image/svg+xml").documentElement;r.setAttribute("transform","translate(0 25)");const o={map:s,position:e,zIndex:n,title:i,content:r};return new google.maps.marker.AdvancedMarkerElement(o)}const l={position:e,zIndex:n,title:i,icon:{url:`data:image/svg+xml;base64,${btoa(a)}`,anchor:new google.maps.Point(25,25)}};return new google.maps.Marker(l)}}
/**
 * Extends an object's prototype by another's.
 *
 * @param type1 The Type to be extended.
 * @param type2 The Type to extend with.
 * @ignore
 */function extend(t,e){for(let r in e.prototype)t.prototype[r]=e.prototype[r]}class OverlayViewSafe{constructor(){extend(OverlayViewSafe,google.maps.OverlayView)}}var r;(function(t){t.CLUSTERING_BEGIN="clusteringbegin";t.CLUSTERING_END="clusteringend";t.CLUSTER_CLICK="click"})(r||(r={}));const defaultOnClusterClickHandler=(t,e,r)=>{r.fitBounds(e.bounds)};class MarkerClusterer extends OverlayViewSafe{constructor({map:t,markers:e=[],algorithmOptions:r={},algorithm:s=new SuperClusterAlgorithm(r),renderer:o=new DefaultRenderer,onClusterClick:a=defaultOnClusterClickHandler}){super();this.markers=[...e];this.clusters=[];this.algorithm=s;this.renderer=o;this.onClusterClick=a;t&&this.setMap(t)}addMarker(t,e){if(!this.markers.includes(t)){this.markers.push(t);e||this.render()}}addMarkers(t,e){t.forEach((t=>{this.addMarker(t,true)}));e||this.render()}removeMarker(t,e){const r=this.markers.indexOf(t);if(r===-1)return false;MarkerUtils.setMap(t,null);this.markers.splice(r,1);e||this.render();return true}removeMarkers(t,e){let r=false;t.forEach((t=>{r=this.removeMarker(t,true)||r}));r&&!e&&this.render();return r}clearMarkers(t){this.markers.length=0;t||this.render()}render(){const t=this.getMap();if(t instanceof google.maps.Map&&t.getProjection()){google.maps.event.trigger(this,r.CLUSTERING_BEGIN,this);const{clusters:e,changed:s}=this.algorithm.calculate({markers:this.markers,map:t,mapCanvasProjection:this.getProjection()});if(s||s==void 0){const t=new Set;for(const r of e)r.markers.length==1&&t.add(r.markers[0]);const r=[];for(const e of this.clusters)e.marker!=null&&(e.markers.length==1?t.has(e.marker)||MarkerUtils.setMap(e.marker,null):r.push(e.marker));this.clusters=e;this.renderClusters();requestAnimationFrame((()=>r.forEach((t=>MarkerUtils.setMap(t,null)))))}google.maps.event.trigger(this,r.CLUSTERING_END,this)}}onAdd(){this.idleListener=this.getMap().addListener("idle",this.render.bind(this));this.render()}onRemove(){google.maps.event.removeListener(this.idleListener);this.reset()}reset(){this.markers.forEach((t=>MarkerUtils.setMap(t,null)));this.clusters.forEach((t=>t.delete()));this.clusters=[]}renderClusters(){const t=new ClusterStats(this.markers,this.clusters);const e=this.getMap();this.clusters.forEach((s=>{if(s.markers.length===1)s.marker=s.markers[0];else{s.marker=this.renderer.render(s,t,e);s.markers.forEach((t=>MarkerUtils.setMap(t,null)));this.onClusterClick&&s.marker.addListener("click",(t=>{google.maps.event.trigger(this,r.CLUSTER_CLICK,s);this.onClusterClick(t,s,e)}))}MarkerUtils.setMap(s.marker,e)}))}}export{AbstractAlgorithm,AbstractViewportAlgorithm,Cluster,ClusterStats,DefaultRenderer,GridAlgorithm,MarkerClusterer,r as MarkerClustererEvents,MarkerUtils,NoopAlgorithm,SuperClusterAlgorithm,SuperClusterViewportAlgorithm,defaultOnClusterClickHandler,distanceBetweenPoints,extendBoundsToPaddedViewport,extendPixelBounds,filterMarkersToPaddedViewport,getPaddedViewport,noop,pixelBoundsToLatLngBounds};

